include "std_lib_facilities.h"

constexpr char quit = 'x';
constexpr char print = '=';

class Token
{
public:
    char kind;			
    double value;		// for numbers: a value 

    
    Token(char ch) : kind(ch), value(0) {}
    Token(char ch, double val) : kind(ch), value(val) {}
};


class Token_stream
{
public:
    // The constructor just sets full to indicate that the buffer is empty:
    Token_stream() : full(false), buffer('\0') {}
    Token get();					  // get a Token (get() is defined elsewhere)
    void putback(Token t);  // put a Token back
private:
    bool full;      				// is there a Token in the buffer?
    Token buffer;					  // here is where we keep a Token put back using putback()
};


{
    if (full)
    {
        error("putback() into a full buffer");
    }
    buffer = t;       // copy t to buffer
    full = true;      // buffer is now full
}



Token Token_stream::get()
{
    Token temp{ '\0' };

  
    if (full)
    {
        full = false;
        temp = buffer;
    }
    else
    {
        char ch;
        std::cin >> ch;
        switch (ch)
        {
        case print:
        case quit:
        case '(': case ')': case '*': case '/': case '+': case '-':
            temp.kind = ch;
            break;
        case '.':
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
        {
            std::cin.putback(ch);     // put digit back into the input stream
            double val;
            std::cin >> val;		  // read a floating-point number
            temp.kind = '8';
            temp.value = val;
            break;
        }
        default:
            error("Bad token");
        }
    }
    return temp;
}



Token_stream ts;        // provides get() and putback() 


double expression();    // declaration so that primary() can call expression()


double primary()
{
    double temp{};        // temp storage for the returns

    Token t = ts.get();
    switch (t.kind)
    {
    case '(':			    // handle '(' expression ')'
    {
        double d = expression();
        t = ts.get();
        if (t.kind != ')')
        {
            error("')' expected");
        }
        temp = d;
        break;
    }
    case '-':			    // deal with - unary operator
        temp = -1 * primary();
        break;
    case '+':			    // deal with + unary operator
        temp = primary();
        break;
    case '8':			    // we use '8' to represent a number
        temp = t.value;  	// return the number's value
        break;
    default:
        error("primary expected");
    }
    return temp;
}


// deal with * and /
// % not implemented yet